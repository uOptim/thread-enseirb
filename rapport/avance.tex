\subsection{Support des machines multiprocesseur}

L'implémentation des threads noyaux est en cours et se sert de l'appel système
\verb!clone! pour créer de nouveau threads dans le même thread group que le
processus parent. Dans cette implémentation, les différents threads se
partagent les listes de threads utilisateurs en attente (ready) et en cours
d'éxécution (running).

Au démarrage, un certain nombre (décidé à la compilation) de threads noyaux
sont créés et exécutent une boucle infinie allant chercher un contexte à
exécuter dans une fifo "ready". Chaque contexte est responsable du lancement du
contexte suivant (lors d'un \verb!yield! ou d'un \verb!exit! par exemple). Si
aucun contexte n'est placé dans la file "ready", il y a retour à la boucle
infinie attendant l'ajout d'un nouveau contexte à exécuter.

Les problèmes d'accès concurrents sont pour l'instant gérés avec des sémaphores
et des mutex fournis par la bibliothèque pthread. S'il nous reste du temps,
l'utilisation de futex est prévue afin de les remplacer.

La destruction des threads noyaux est prise en charge par le destructeur
(fonction \verb!__destroy()!) qui envoie une série de signaux SIGTERM aux
threads issus de l'appel à \verb!clone! avant de libérer les ressources qu'ils
occupaient.


\subsection{Préemption} 

L'implémentation de la préemption est en cours. Nous avons utilisé la fonction
$ualarm$ pour envoyer un signal d'alarme $SIGALRM$ à intervalles réguliers. Ce
signal est bloqué par un gestionnaire de signaux initialisé en même temps que
la bibliothèque $thread.h$. Le handler correspondant à ce gestionnaire est donc
appelé et passe la main du contexte courant à un contexte spécialement dédié à
l'ordonnancement. Ce contexte ordonnanceur passe la main au contexte suivant de
la liste $ready$. Une amélioration prévue est de laisser chaque thread démarrer
le contexte suivant afin de limiter le nombre d'appels à \verb!swapcontext()!.

Dans le cas particulier où la liste $ready$ est vide ou ne comprend qu'un seul
thread, il n'est pas nécessaire d'avoir recours à la préemption. Il faut donc
désactiver le gestionnaire correspondant à $SIGALRM$ jusqu'à ce qu'un nouveau
thread soit inséré dans la liste.

Une fois la préemption fonctionnelle, nous envisageons de mettre en place la
gestion des priorités. Elle sera réalisée grâce à la préemption, en donnant
plus souvent la main aux processus de haute priorité.
 
\subsection{Annulation d'un autre thread (thread\_cancel())}
L'implémentation des threads noyaux est en cours et se sert de l'appel système clone pour créer de nouveaux threads dans le même thread group que le processus parent. Dans cette implémentation, les différents threads se partagent les listes de threads utilisateurs en attente (ready) et en cours d'éxécutions (running).

Au démarrage, un certain nombre (décidé à la compilation) de threads noyaux sont créés et exécutent une boucle infinie allant chercher un contexte à exécuter dans une fifo "ready". Chaque contexte est responsable du lancement du contexte suivant (lors d'un yield ou d'un exit par exemple). Si aucun contexte n'est placé dans la file "ready", il y a retour à la boucle infinie attendant l'ajout d'un nouveau contexte à exécuter.

Les problèmes d'accès concurrents sont pour l'instant gérés avec des sémaphores et des mutex fournis par la bibliothèque pthread. S'il nous reste du temps, l'utilisation de futex est prévue afin de les remplacer.

La destruction des threads noyaux est prise en charge par le destructeur (fonction \verb!__destroy()!) qui envoie une série de signaux SIGTERM aux threads issus de l'appel à clone avant de libérer les ressources qu'ils occupaient.
